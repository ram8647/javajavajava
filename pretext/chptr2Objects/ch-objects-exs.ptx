<section xml:id="ch-objects-exs">
  <title>Exercises</title>
  <exercises>
    <exercise label="joex_grade_transaction">
      <statement>
        <p>
          Consider the transaction of asking your professor for your grade in your computer science course.
          Identify the objects in this transaction and the types of messages that would be passed among them.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_automate_grade_transaction">
      <statement>
        <p>
          Now suppose the professor in the previous exercise decides to automate the transaction
	  of looking up a student's grade and has asked you to design a program to perform this task.
          The program should let a student type in his or her name and ID number and the program
	  then should display his or her grades for the semester,
          with a final average.
          Suppose there are five quiz grades, three exams,
          and two programming exercise grades.
          Identify the objects in this program and the type of messages that would be passed among them.
          (<em>Hint</em>: The grades themselves are just data values,
          not objects.)

        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_riddle_user_instantiation">
      <statement>
        <p>
          In the <c>RiddleUser</c> class (<xref ref="fig-riddleuser"></xref>),
          give two examples of object instantiation and explain what is being done.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_method_def_vs_call">
      <statement>
        <p>
          Explain the difference between a method definition and a method call.
          Give an example of each from the <c>Riddle</c> and <c>RiddleUser</c> examples discussed in this chapter.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_riddle_user_method_calls">
      <statement>
        <p>
          In the <c>RiddleUser</c> class (<xref ref="fig-riddleuser"></xref>),
          identify three examples of method calls and explain what is being done.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_explain_define_create_manipulate">
      <statement>
        <p>
          Describe how the slogan
          <q>define, create, manipulate</q>
          applies to the <c>Riddle</c> example.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_identifier_definition">
      <statement>
        <p>
          An identifier is the name for a <var width="10" />, a <var
	  width="10" />, or a  <var width="10" />. (Answer in alphabetical order) 
        </p>
      </statement>
      <setup>
        <var>
          <condition case="insensitive" string="class">
            <feedback>
	      <p>Correct, a class has an identifier or name, which
	      is the type of Object.</p>
            </feedback>
          </condition>
          <condition case="insensitive" string="method">
            <feedback>
	      <p>Try Again, Wrong Order, a method has an identifier
	      or name, but this answer is expected in the second blank.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="variable">
            <feedback>
	      <p>Try Again, Wrong Order, a variable has an
	      identifier or name, but this answer is expected in the third blank.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="field">
            <feedback>
	      <p>Try Again, a field is a special type of a variable
	      that is part of a class so it's too specific.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="function">
            <feedback>
	      <p>Try Again, a general function is not allowed in
	      java only methods that are part of a class or object
	      are allowed.</p>
            </feedback>
          </condition>
          <condition string=".*">
            <feedback>
	      <p>Try again. Think about what you can give names to
	      in java.</p>
            </feedback>
          </condition>
        </var>
	<var>
          <condition case="insensitive" string="method">
            <feedback>
	      <p>Correct, a method has an identifier
	      or name, but this answer is expected in the second blank.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="class">
            <feedback>
	      <p>Try Again, Wrong Order, a class has an identifier or name, which
	      is the type of Object, but this answer is expected in
	      the first blank.</p>
            </feedback>
          </condition>
          <condition case="insensitive" string="variable">
            <feedback>
	      <p>Try Again, Wrong Order, a variable has an
	      identifier or name, but this answer is expected in the third blank.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="field">
            <feedback>
	      <p>Try Again, a field is a special type of a variable
	      that is part of a class so it's too specific.</p>
            </feedback>
          </condition>
          <condition case="insensitive" string="function">
            <feedback>
	      <p>Try Again, a general function is not allowed in
	      java only methods that are part of a class or object
	      are allowed.</p>
            </feedback>
          </condition>
          <condition string=".*">
            <feedback>
	      <p>Try again. Think about what you can give names to
	      in java.</p>
            </feedback>
          </condition>
        </var>
	<var>
          <condition case="insensitive" string="variable">
            <feedback>
	      <p>Correct, a variable has an
	      identifier or name, but this answer is expected in the third blank.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="class">
            <feedback>
	      <p>Try Again, Wrong Order, a class has an identifier or name, which
	      is the type of Object, but this answer is expected in
	      the first blank.</p>
            </feedback>
          </condition>
          <condition case="insensitive" string="method">
            <feedback>
	      <p>Try Again, Wrong Order, a method has an identifier
	      or name, but this answer is expected in the second blank.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="field">
            <feedback>
	      <p>Try Again, a field is a special type of a variable
	      that is part of a class so it's too specific.</p>
            </feedback>
          </condition>
	  <condition case="insensitive" string="function">
            <feedback>
	      <p>Try Again, a general function is not allowed in
	      java only methods that are part of a class or object
	      are allowed.</p>
            </feedback>
          </condition>
	  
          <condition string=".*">
            <feedback>
	      <p>Try again. Think about what you can give names to
	      in java.</p>
            </feedback>
          </condition>
        </var>
      </setup>
    </exercise>
    <exercise label="joex_valid_identifiers_mc">
      <statement>
        <p>
          Which of the following would be valid identifiers?
	  <program language="java"><input>
	    int  74ElmStreet  Big_N     L$&amp;%#   boolean  Boolean  _number
	    Int  public       Private   Joe     j1       2*K      big numb
	  </input></program>
        </p>
      </statement>
      <choices multiple-correct="yes" randomize="yes">
	<choice correct="yes">
	  <statement> Big_N </statement><feedback>Yes, many java style
	  conventions would use <c>Big_N</c> as a class name since the first
	  leter is captialized.</feedback>
	</choice>

	<choice correct="yes">
	  <statement>
	    Boolean
	  </statement>
	  <feedback>Yes, <c>Boolean</c> is the
	    identifier/class name for the wrapper class of the
	    <c>boolean</c> primitive type, and it can be re-used as a
	  variable identifier.</feedback>
	</choice>
	
	<choice correct="yes">
	  <statement>
	    _number
	  </statement>
	  <feedback>Yes,
	starting with underscore is done in some coding conventions
	to signify a field name or a private field name.</feedback>
	</choice>
	
	<choice correct="yes">
	  <statement>
	    Int
	  </statement>
	  <feedback>Yes, However <c>Int</c> is not the
	    identifier/class name for the wrapper class of the
	    <c>boolean</c> primitive type, instead <c>Integer</c> is
	  used.</feedback>
	</choice>
	
	<choice correct="yes">
	  <statement>
	    Private
	  </statement>
	  <feedback>Yes, many java style
	  conventions would use <c>Private</c> as a class name since the first
	  leter is captialized.</feedback>
	</choice>

	<choice correct="yes">
	  <statement>
	    Joe
	  </statement>
	  <feedback>Yes, many java style
	  conventions would use <c>Joe</c> as a class name since the first
	  leter is captialized.</feedback>
	</choice>


	<choice correct="yes">
	  <statement>
	    j1
	  </statement>
	  <feedback>Yes, as long as the numerical digit is
	    not the first character, it is allowed as part of an
	    identifier, so <c>j1</c> is a legal identifier, and most
	    Java coding conventions would have it be a variable, field,
	  or method name.</feedback>
	</choice>


	<choice>
	  <statement>
	    public
	  </statement>
	  <feedback>Try again,
	  <c>public</c> is a reserved access modifier word.</feedback>
	</choice>


	<choice>
	  <statement>L$&amp;%#</statement>
	  <feedback>Try again, the only non-alphanumeric character allowed
	  in identifiers is the underscore, <c>_</c>, so L$&amp;%# is not allowed</feedback>
	</choice>
	<choice>
	  <statement>boolean</statement>
	  <feedback>Try again, <c>boolean</c> is a reserved word</feedback>
	</choice>

	<choice>
	  <statement>int</statement>
	  <feedback>Try again, <c>int</c> is a reserved word</feedback>
	</choice>
	<choice>
	  <statement>74ElmStreet</statement>
	  <feedback>Try again, identifiers can't start with a number</feedback>
	</choice>
	<choice>
	  <statement>
	    2*K
	  </statement>
	  <feedback>Try again, <c>2*K</c> is an expression, and identifiers
	  can't start with a number or have any symbol other than _
	  (underscore) in them.</feedback>
	</choice>

	<choice>
	  <statement>
	    big numb
	  </statement>
	  <feedback>Try again, <c>big numb</c> has a space in it, and identifiers
	  can't have any non-alphanumeric character other than _
	  (underscore) in them.</feedback>
	</choice>
      </choices>
    </exercise>
    <exercise label="joex_class_vs_instance_variable">
      <statement>
        <p>
          Explain the difference between a <c>class variable</c> and an <c>instance variable</c>.
        </p>
      </statement>
      <response />
    </exercise>
    <exercisegroup>
      <title>Declaring fields</title>
      <introduction>
        <p>
          Identify the syntax error
          (if any)
          in each declaration.
          Remember that some parts of an instance variable declaration are optional.
        </p>
      </introduction>
      <exercise label="joex_public_is_even">
	<statement> 
          <program language="java"><input>public boolean isEven;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_private_is_even">
	<statement> 
          <program language="java"><input>Private boolean isEven;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_private_is_odd">
	<statement> 
          <program language="java"><input>private boolean isOdd</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_public_is_odd">
	<statement> 
          <program language="java"><input>public boolean is Odd;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_string_s">
	<statement> 
          <program language="java"><input>string S;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_string_boolean">
	<statement> 
          <program language="java"><input>public String boolean;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_boolean_initialization">
	<statement> 
          <program language="java"><input>private boolean even = 0;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_string_initialization">
	<statement> 
          <program language="java"><input>private String s = helloWorld;</input></program>
        </statement>
	<response />
      </exercise>                 
    </exercisegroup>
    <exercisegroup>
      <title>Writing declarations</title>
      <introduction>
        <p>
          Write declarations for each of the following instance variables.
        </p>
      </introduction>
      <exercise label="joex_boolean_bool">
	<statement>
          <p>
            A <c>private boolean</c> variable named <c>bool</c> that has an initial value of <c>true</c>.
          </p>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_string_str">
	<statement>
          <p>
            A <c>public String</c> variable named <c>str</c> that has an initial value of "hello".
          </p>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_int_employees">
	<statement>
          <p>
            A <c>private int</c> variable named <c>nEmployees</c> that is not assigned an initial value.
          </p>
        </statement>
	<response />
      </exercise>
    </exercisegroup>

    <exercisegroup>
      <title>Method syntax</title>
      <introduction>
        <p>
          Identify the syntax error
          (if any)
          in each method header:
        </p>
      </introduction>

      <exercise label="joex_boolean_method">
	<statement> 
          <program language="java"><input> public String boolean()</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_string_method">
	<statement> 
          <program language="java"><input>private void String ()</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_void_myMethod">
	<statement> 
          <program language="java"><input>private void myMethod</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_private_myMethod">
	<statement> 
          <program language="java"><input>private myMethod()</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_static_main_method">
	<statement> 
          <program language="java"><input>public static void Main (String argv[])</input></program>
        </statement>
	<response />
      </exercise> 

    </exercisegroup>
    <exercisegroup>
      <title>Variable Assignment</title>
      <introduction>
        <p>
          Identify the syntax error (if any) in each assignment statement.
          Assume that the following variables have been declared:
        </p>
	<program language="java"><input>
	  public int m;
	  public boolean b;
	  public String s;
	</input></program>
      </introduction>
      <exercise label="joex_va_a">
	<statement> 
          <program language="java"><input>m = "86";</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_va_b">
	<statement> 
          <program language="java"><input>m = 86;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_va_c">
	<statement> 
          <program language="java"><input>m = true;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_va_d">
	<statement> 
          <program language="java"><input>s = 1295;</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_va_e">
	<statement> 
          <program language="java"><input>s = "1295";</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_va_f">
	<statement> 
          <program language="java"><input>b = "true";</input></program>
        </statement>
	<response />
      </exercise>
      <exercise label="joex_va_g">
	<statement> 
          <program language="java"><input>b = false</input></program>
        </statement>
	<response />
      </exercise>        
      
    </exercisegroup>
    <exercise label="joex_number_adder_main">
      <statement>
        <p>
          Given the following definition of the <c>NumberAdder</c> class,
          add statements to its <c>main()</c> method to create two instances of this class,
          named <c>adder1</c> and <c>adder2</c>. Then add statements to set <c>adder1</c>'s numbers to 10 and 15,
          and <c>adder2</c>'s numbers to 100 and 200.
          Then add statements to print their respective sums.
	</p>
      </statement>
      <program label="joex_number_adder_prg" language="java" interactive="activecode"><input>
	public class NumberAdder
	{
	private int num1;
	private int num2;
	public void setNums(int n1, int n2)
	{
	num1 = n1;
	num2 = n2;
	}
	public int getSum()
	{
	return num1 + num2;
	}
	public static void main(String args[])
	{
	}
	}
      </input>
	<tests>
          <![CDATA[
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.lang.reflect.*;

public class RunestoneTests extends CodeTestHelper
{

    public RunestoneTests() {
	super("NumberAdder");
    }
    
    @Test
    public void test1()
    {
    String target = "25";
	String actual = getMethodOutput("main");
	expect(true, actual.contains(target),"output contains " + target);
	
    }
    @Test
    public void test1b()
    {
        String target = "300";

	String actual = getMethodOutput("main");
	expect(true, actual.contains(target),"output contains " + target);

    }

    

}


          ]]>
	</tests>

      </program>
    </exercise>
    <exercise label="joex_number_adder_describe">
      <statement>
        <p>
          For the <c>NumberAdder</c> class in the previous exercise,
          what are the names of its instance variables and instance methods?
          Identify three expressions that occur in the program and explain what they do.
          Identify two assignment statements and explain what they do.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_matching_terms">
      <title>Matching Concepts Objects</title>
      <setup>
        <p>
         Match the Object terms to definitions.
	</p>
      </setup>
            <matches>
	<match>
	  <order>1</order>
          <premise><em>method definition</em></premise>
          <response>the part of the code that contains the exe-
cutable statements that the method performs </response>
	</match>
	<match>
	  <order>2</order>
          <premise><em>method call</em></premise>
          <response>the act of calling the method to perform the task it is meant to perform.</response>
	</match>
	<match>
	  <order>3</order>
          <premise><em>declaring a variable of reference type</em></premise>
          <response>Specifying an object type and an identifier for
	  the object</response>
	</match>
	<match>
	  <order>4</order>
          <premise><em>creating an instance</em></premise>
          <response>using the keyword <c>new</c> along with an
	  object's constructor.</response>
	</match>
	<match>
	  <order>5</order>
	  <premise><em>primitive type variable</em> </premise>
          <response>an identifier that has memory for the actual value
	  of the variable</response>
	</match>
	<match>
	  <order>6</order>
          <premise><em>reference type variable</em> </premise>
          <response>an identifier that has memory for the reference to
	  the object that holds the values of the variable.</response>
	</match>
	
      </matches>

      
      </exercise>
    
    
    <exercise label="joex_number_cruncher">
      <statement>
        <p>
          Define a Java class named <c>NumberCruncher</c> that has a
	  single <c>int</c> variable as its only instance
	  variable(a.k.a. field).
          Then define methods that perform the following operations on its number:
          getVal, doubleVal, tripleVal, squareVal, and cubeVal that returns the
	  result, but doesn't modify the object.
          Set the initial value of the number with a constructor as was done with the instance variables in the <c>Riddle</c> class.
        </p>
      </statement>
      <program label="joex_number_cruncher_class" language="java"
	       interactive="activecode"><input>
	public class NumberCruncher {

	}
      </input>
      	<tests>
          <![CDATA[
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.lang.reflect.*;

public class RunestoneTests extends CodeTestHelper
{

    public RunestoneTests() {
	super("NumberCruncher");
    }


    private Object getTestInstance(Object[] defaultTestValues) {
        String errorMessage = "";
        try {
	    Class<?> c = Class.forName("NumberCruncher");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

	    return ctor.newInstance((Object[])null);

} catch (Exception e) {
try {
Class<?> c = Class.forName("NumberCruncher");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

return ctor.newInstance(defaultTestValues);
}catch (Exception e2) {
errorMessage = "Couldn't call constructor";
}
        }

        return null;
    }
    
    @Test
    public void test1()
    {
	String target = "1 Private";
	String actual = testPrivateInstanceVariables();
	expect(target,actual,"exactly 1 private field");
	
    }
    @Test
    public void test1b()
    {
	boolean found = true;
	String[] types = {"int"};
	String fieldTypes =
	    testInstanceVariableTypes(types);
	if (fieldTypes.trim().equals("") || fieldTypes.equals("fail")) {
	    found = false;
	} else {
	    String[] typeNames = fieldTypes.trim().split(" ");
	    if(typeNames.length != 1 || !typeNames[0].equals("int")
	    ) {
		found = false;
	    }
	    if(types[0] != null) {
		found = false;
	    }

	}

	expect(true,found,"has exactly 1 int field");
    }

    @Test
    public void test2()
    {
    int value = 3;
    int target = 3;
    String methodName = "getVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    }
    @Test
    public void test2b()
    {
int value = 3;
    	    int target = 6;
	String methodName = "doubleVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }

 @Test
    public void test3()
    {
int value = 4;
    	    int target = 12;
	String methodName = "tripleVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }


@Test
    public void test4()
    {
int value = 4;
    	    int target = 16;
	String methodName = "squareVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }

@Test
    public void test5()
    {
int value = 3;
    	    int target = 27;
	String methodName = "cubeVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }


@Test
    public void test6()
    {
    int value = 5;
    int target = 5;
    String methodName = "getVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    }
    @Test
    public void test7()
    {
int value = 5;
    	    int target = 10;
	String methodName = "doubleVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }

 @Test
    public void test8()
    {
int value = 1;
    	    int target = 3;
	String methodName = "tripleVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }


@Test
    public void test9()
    {
int value = 6;
    	    int target = 36;
	String methodName = "squareVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }

@Test
    public void test10()
    {
int value = 7;
    	    int target = 343;
	String methodName = "cubeVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    
    }


@Test
    public void test11()
    {
    int value = 5;
    int target = 5;
    String methodName = "getVal";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod("doubleVal");
	    m.invoke(t);
	    t.getClass().getMethod("doubleVal");
	    m.invoke(t);
	    t.getClass().getMethod("tripleVal");
	    m.invoke(t);
	    t.getClass().getMethod("squareVal");
	    m.invoke(t);
	    t.getClass().getMethod("cubeVal");
	    m.invoke(t);
	    m = t.getClass().getMethod(methodName); 
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "doubleVal, tripleVal,squareVal, and cubeVal don't" +
		   " change the value");
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't " +
		   "work, or doubleVal, tripleVal, squareVal, or " +
		   "cubeVal changes the value");
	}
    }

   
}

          ]]>
	</tests>

      </program>
    </exercise>
    <exercise label="joex_number_cruncher_instance">
      <statement>
        <p>
          Write a <c>main()</c> method and add it to the
	  <c>NumberCruncher</c> class defined in the previous problem.
          Use it to create a <c>NumberCruncher</c> instance,
          with a certain initial value,
          and then get it to report its double, triple, square, and cube.
        </p>
      </statement>
      <program label="joex_number_cruncher_prg_main" language="java"
	       interactive="activecode"><input>
	public class NumberCruncher {
	// copy code from previous problem and add main method
	}
      </input>
      </program>

    </exercise>
    <exercise label="joex_cube_class_definition">
      <statement>
        <p>
          Write a Java class definition for a <c>Cube</c> object,
          that has an integer attribute for the length of its side.
          The object should be capable of reporting its surface area and volume.
          The surface area of a cube is six times the area of any side.
          The volume is calculated by cubing the side.
        </p>
      </statement>
      <program label="joex_cube_class" language="java"
	       interactive="activecode"><input>
	public class Cube {

	}
      </input>
      	<tests>
          <![CDATA[
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.lang.reflect.*;

public class RunestoneTests extends CodeTestHelper
{

    public RunestoneTests() {
	super("Cube");
    }


    private Object getTestInstance(Object[] defaultTestValues) {
        String errorMessage = "";
        try {
	    Class<?> c = Class.forName("Cube");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

	    return ctor.newInstance((Object[])null);

} catch (Exception e) {
try {
Class<?> c = Class.forName("Cube");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

return ctor.newInstance(defaultTestValues);
}catch (Exception e2) {
errorMessage = "Couldn't call constructor";
}
        }

        return null;
    }
    
    @Test
    public void test1()
    {
	String target = "1 Private";
	String actual = testPrivateInstanceVariables();
	expect(target,actual,"exactly 1 private field");
	
    }
    @Test
    public void test1b()
    {
	boolean found = true;
	String[] types = {"int"};
	String fieldTypes =
	    testInstanceVariableTypes(types);
	if (fieldTypes.trim().equals("") || fieldTypes.equals("fail")) {
	    found = false;
	} else {
	    String[] typeNames = fieldTypes.trim().split(" ");
	    if(typeNames.length != 1 || !typeNames[0].equals("int")
	    ) {
		found = false;
	    }
	    if(types[0] != null) {
		found = false;
	    }

	}

	expect(true,found,"has exactly 1 int fields");
    }

    @Test
    public void test2()
    {
    int value = 3;
    int target = 6 * value * value;
    String methodName = "getSurfaceArea";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + " work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + " don't work");
	}
    }
    @Test
    public void test2b()
    {
int value = 7;
    	    int target = 6 * value * value;
	String methodName = "getSurfaceArea";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    
    }

 @Test
    public void test3()
    {
int value = 4;
    	    int target = value * value * value;
	String methodName = "getVolume";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    
    }


@Test
    public void test4()
    {
int value = 9;
    	    int target = value * value * value;
	String methodName = "getVolume";
	try {
	    Object[] testValues = {value};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    
    }

 
   
}

          ]]>
	</tests>

      </program>
    </exercise>
    <exercise label="joex_cube_user_class_definition">
      <statement>
        <p>
          Write a Java class definition for a <c>CubeUser</c> object that will use the <c>Cube</c> object defined in the previous exercise.
          This class should create three <c>Cube</c> instances,
          each with a different side length,
          and then report their respective surface areas and volumes.
        </p>
      </statement>
      <program label="joex_cube_user_prg" language="java"
	       interactive="activecode"><input>
	// copy Cube code from above and paste it as a protected class
	// (with a public constructor)

	public class CubeUser {

	public static void main(String[] args) {

	}

	}
      </input>
      </program>
    </exercise>

    <exercise label="joex_cube_user_side_choice">
      <statement>
        <p>
          Challenge: Modify your solution to the previous exercise so that it lets the user input the side of the cube.
          Follow the example shown in this chapter's
          <q>From the Java Library</q>
          section. Specifically look at
	  <xref ref="list-scannerprog">Listing</xref>
        </p>
      </statement>
      <program label="joex_cube_user_side_choice_prg" language="java"
	       interactive="activecode"><input>
	// copy Cube and CubeUser code from above and paste 
	// it instead of the below code

	public class CubeUser {

	public static void main(String[] args) {

	}

	}
      </input>
      </program>
    </exercise>



     <exercise label="joex_address_book_class">
      <statement>
        <p>
          Challenge: Define a Java class that represents an address book entry, <c>Entry</c>, which consists of a name,
          address, and phone number,
          all represented as <c>String</c> s.
          For the class's interface,
          define methods to get the values of each of its instance variables.
          Thus, for the <c>name</c> variable,
          it should have a <c>getName()</c> method. The constructor
	  should take the name, address, and phone number as arguments. 
        </p>
      </statement>
      <program label="joex_address_book_code" language="java"
	       interactive="activecode"><input>
	
	public class AddressBookEntry {

	

	}
      </input>
      	<tests>
          <![CDATA[
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.lang.reflect.*;

public class RunestoneTests extends CodeTestHelper
{

    public RunestoneTests() {
	super("AddressBookEntry");
    }


    private Object getTestInstance(Object[] defaultTestValues) {
        String errorMessage = "";
        try {
	    Class<?> c = Class.forName("AddressBookEntry");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

	    return ctor.newInstance((Object[])null);

} catch (Exception e) {
try {
Class<?> c = Class.forName("AddressBookEntry");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

return ctor.newInstance(defaultTestValues);
}catch (Exception e2) {
errorMessage = "Couldn't call constructor";
}
        }

        return null;
    }
    
    @Test
    public void test1()
    {
	String target = "3 Private";
	String actual = testPrivateInstanceVariables();
	expect(target,actual,"exactly 3 private fields");
	
    }
    @Test
    public void test1b()
    {
	boolean found = true;
	String[] types = {"String","String","String"};
	String fieldTypes =
	    testInstanceVariableTypes(types);
	if (fieldTypes.trim().equals("") || fieldTypes.equals("fail")) {
	    found = false;
	} else {
	    String[] typeNames = fieldTypes.trim().split(" ");
	    if(typeNames.length != 3 || !typeNames[0].equals("String")
	    || !typeNames[1].equals("String") || !typeNames[2].equals("String") ) {
		found = false;
	    }
	    if(types[0] != null || types[1] != null || types[2] != null) {
		found = false;
	    }

	}

	expect(true,found,"has exactly 3 String fields");
    }

    @Test
    public void test2()
    {
    String name = "Drew Dynomite"; 
    String address = "3 Pie Lane Apt. 14"; 
    String phone = "314-159-2653"; 
    String target = name;
    String value = name;
    String methodName = "getName";
	try {
	    Object[] testValues = {name,address,phone};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    String actual = (String) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }
    @Test
    public void test2b()
    {
    String name = "Drew Dynomite"; 
    String address = "3 Pie Lane Apt. 14"; 
    String phone = "314-159-2653"; 
    String target = address;
    String value = target;
    String methodName = "getAddress";
	try {
	    Object[] testValues = {name,address,phone};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    String actual = (String) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }

 @Test
    public void test3()
    {
    String name = "Drew Dynomite"; 
    String address = "3 Pie Lane Apt. 14"; 
    String phone = "314-159-2653"; 
    String target = phone;
    String value = target;
    String methodName = "getPhone";
	try {
	    Object[] testValues = {name,address,phone};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    String actual = (String) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    
    }


    @Test
    public void test4()
    {
    String name = "Cam Coder"; 
    String address = "264 H Drive"; 
    String phone = "640-480-1080"; 
    String target = name;
    String value = name;
    String methodName = "getName";
	try {
	    Object[] testValues = {name,address,phone};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    String actual = (String) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }
    @Test
    public void test5()
    {
    String name = "Cam Coder"; 
    String address = "264 H Drive"; 
    String phone = "640-480-1080"; 
    String target = address;
    String value = target;
    String methodName = "getAddress";
	try {
	    Object[] testValues = {name,address,phone};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    String actual = (String) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }

 @Test
    public void test6()
    {
    String name = "Cam Coder"; 
    String address = "264 H Drive"; 
    String phone = "640-480-1080"; 
    String target = phone;
    String value = target;
    String methodName = "getPhone";
	try {
	    Object[] testValues = {name,address,phone};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    String actual = (String) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    
    }



   
}

          ]]>
	</tests>

      </program>
    </exercise>




    
    <exercise label="joex_uml_language_classes" attachment="yes">
      <statement>
        <p>
          Draw a UML class diagram to represent the following class hierarchy: There are two types of languages,
          natural languages and programming languages.
          The natural languages include Chinese, English, French,
          and German.
          The programming languages include Java, Smalltalk and C++, which are object-oriented languages, FORTRAN, COBOL, Pascal,
          and C, which are imperative languages, Lisp and ML, which are functional languages,
          and Prolog, which is a logic language.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_uml_automobile_classes" attachment="yes">
      <statement>
        <p>
          Draw a UML class diagram to represent different kinds of automobiles,
          including trucks, sedans,
          wagons, SUVs, and the names and manufacturers of some popular models in each category.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_uml_triangle_object" attachment="yes">
      <statement>
        <p>
          Draw a UML object diagram of a triangle with attributes for three sides,
          containing the values 3, 4, and 5.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_uml_address_book_ui" attachment="yes">
      <statement>
        <p>
          Suppose you are writing a Java program to implement an electronic address book.
          Your design is to have two classes,
          one to represent the user interface and one to represent the address book.
          Draw a UML diagram to depict this relationship.
          See <xref ref="fig-p63f2">Figure</xref>.
        </p>
      </statement>
      <response />
    </exercise>
    <exercise label="joex_uml_object_relationship" attachment="yes">
      <statement>
        <p>
          Draw an UML object diagram to depict the relationship between a program that extends <c>Canvas</c>,
          which serves as a user interface, and which draws three instances of a <c>Triangle</c> class
          named <c>t1</c>, <c>t2</c>, and <c>t3</c>.
        </p>
      </statement>
      <response />
    </exercise>
  </exercises>
</section> 
