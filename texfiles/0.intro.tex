%%%  Chapter 0: Computers, Objects and Java
%%%  3rd Edition
\setcounter{SSTUDYcount}{1}
\setcounter{chapter}{-1}

\chapter{Computers, \mbox{Objects}, and Java}
\label{chapter-intro}

\CObegin
\secCOBH{Objectives}
\noindent After studying this chapter, you will

\begin{COBL}
\item  Understand basic computer terminology that
       will be used throughout the book.
\item  Become familiar with the notion of programming.
\item  Understand why Java is a good introductory
       programming language.
\item  Become familiar with Java objects and classes.
\item  Know some of the principles
       of the object-oriented programming approach.
%%\item  Recognize Unified Modeling Language (UML) diagrams.
\end{COBL}

\secCOLH{Outline}
\begin{COL}
\item Welcome
\item What Is a Computer?
\item[] {{\color{cyan}Special Topic:} Processors Then and Now} 
\item Networks, the Internet and the World Wide Web
\item Why Study Programming?
\item Programming Languages
\item Why Java?
\item What Is Object-Oriented Programming?
\par\small\item[] Chapter Summary
\par\small\item[] Exercises
\end{COL}
\COend

\section{Welcome}
\noindent Welcome to  {\it Java, Java, Java}, a book that introduces you to
object-oriented programming using the Java language.  When considering
the purpose of this text, three important questions might come to
mind: Why study programming?  Why study Java? What is object-oriented
programming?  This chapter will address these questions. First, we
provide a brief introduction to computers and the Internet and World
Wide Web (WWW). Then, we address why someone would study programming
and we examine types of programming languages. We introduce the Java
programming language and conclude the chapter by exploring
object-oriented programming principles and how Java is an
object-oriented programming language.

\vspace{-12pt}\section{What Is a Computer?}
\noindent A {\it computer} is a machine that performs calculations and
processes information.  A computer works under the control of a
computer program, a set of instructions that tell a computer what to
do.  {\it Hardware} refers to the electronic and mechanical components
of a computer.  {\it Software} refers to the programs that control the
hardware.

A {\it general-purpose computer} of the sort that we will be
programming can store many different programs in its memory. That is
what gives it the ability to perform a wide variety of functions, from
word processing to browsing the Internet. This is in contrast to a
{\it special-purpose computer}, such as the one that resides in your
microwave oven or the one that controls your digital watch or
calculator.  These types of computers contain control programs that
are fixed and cannot be changed.

A computer's hardware is organized into several main subsystems or
components (Fig.~\ref{fig-blockdiagram}).

%%%RAM\vspace{-6pt}
\begin{figure}[h]
%\begin{graphic}
\figaleft{chptr00/blockdia.eps}
%%\figa{chptr00/blockdia.eps}
{A diagram of the main functional
components in a computer system. The arrows indicate the flow of information
between various components.
\label{fig-blockdiagram}}
%\end{graphic}
\end{figure}

\begin{BL}
%%%\begin{itemize}
\item  {\it Output devices} provide a means by which information
held in the computer can be displayed in some understandable or usable
form.  Common output devices include printers, monitors, and audio
speakers.

\vspace{5pt}\item  {\it Input devices} bring data and information into
the computer.   Some of the more common input devices are the keyboard,
mouse, microphone, and scanner.

\vspace{5pt}\item  {\it Primary memory\index{computer memory}}
or {\it main memory} of a computer is used to store both data and
programs.  This type of memory, which is often called {\em RAM}, short
for {\em Random Access Memory}, is built entirely out of electronic
components---integrated circuit chips---which makes it extremely fast.
A computer's main memory is {\it volatile}, which means that any
information stored in it is lost when the computer's power is turned
off.  In a sense, main memory acts as the computer's scratch pad,
storing both programs and data temporarily while a program is running.

\vspace{5pt}\item  {\it Secondary storage\index{computer 
storage}} devices are used for long-term or permanent storage of
relatively large amounts of information.  These devices include
hard drives or magnetic disks, compact disks (CDs), digital video disks
(DVDs), and magnetic tapes.  All of these devices are {\it
non-volatile}, meaning that they retain information when the computer's
power is turned off.  Compared to a computer's primary memory, these
devices are relatively slow.

\vspace{5pt}\item  The {\it central processing unit\index{central 
processing unit}
(CPU\index{CPU})} is the computer's main engine.  The CPU is the
computer's {\it microprocessor}, such as the Intel Pentium processor,
which serves as the foundation for most Windows PCs, or the Power-PC
processor, which serves as the foundation for Macintosh computers.
\marginnote{Fetch-execute cycle}
The CPU is designed to perform the {\em fetch-execute
cycle}\index{fetch-execute cycle}, whereby it repeatedly gets the
next machine instruction from memory and executes it.  Under the
direction of computer programs (software), the CPU issues signals that
control the other components that make up the computer system.  One
portion of the CPU, known as the {\it arithmetic-logic unit (ALU)},
performs all calculations, such as addition and subtraction, and all
logical comparisons, such as when one piece of data is compared to
another to determine if they are equal.
%%%\end{itemize}
\end{BL}


\vspace{7pt}\noindent There are two main types of software:\index{software}

\vspace{7pt}
\begin{BL}
\item  {\it Application software} refers to programs designed
to provide a particular task or service, such as word processors,
computer games, spreadsheet programs, and Web browsers.

\vspace{5pt}\item  {\it System software} includes programs that perform the
basic operations that make a computer usable.  For example, an
important piece of system software is the {\it operating system},
which contains programs that manage the data stored on the computer's
disks. 
\end{BL}

An operating system assists application software in performing tasks
that are considered {\em primitive} or low-level, such as managing the
computer's memory and its input and output devices.

Another important thing that the operating system does is to serve as
an interface between the user and the hardware.  The operating system
determines how the user will interact with the system, or conversely,
how the system will look and feel to the user.  For example, in {\it
command-line} systems, such as Unix and DOS (short for Disk Operating
System), a program is run by typing its name on the command line.  By
contrast, in graphically based systems, such as Windows and Macintosh,
a program is run by clicking on its icon with the mouse.  Thus, this
``point-and-click'' interface has a totally different ``look and
feel'' but does the same thing.

\section*{{\color{cyan}Special Topic:} Processors Then and Now} 

{\color{cyan}To give} you some idea of how rapidly computer hardware technology
has advanced, let's compare the first digital processor with one of
today's models.

The {\it ENIAC} (which stood for Electronic Numerical 
Integrator and Calculator) was developed in 1946 at the University of
Pennsylvania primarily for calculating ballistic trajectories for the
U.S. Army.  ENIAC occupied more than 640 square feet of floor space
and weighed nearly 30 tons.  Instead of the {\it integrated circuits}
or chip technology used in today's computers, ENIAC's digital
technology was based on over 17,000 vacuum tubes.  ENIAC, which could
perform around 300 multiplications per second, ran more than 500 times
faster than other computing machines of that day and age.  To program
the ENIAC, you would have to manipulate hundreds of cables and
switches.  It took two or three days for a team of several
programmers, most of whom were young women, to set up a single program
that would then run for a few seconds.

One of today's most advanced and powerful processors for desktop
computers is Intel's Pentium IV processor.  This chip contains 42
million transistors and runs at speeds over 3 GHz (3 gigahertz or 3
billion cycles per second). The Pentium processor is small enough to
fit in a space the size of your pinky finger's fingernail. Despite its
size, it executes millions of instructions per second, thereby
enabling it to support a huge range of multimedia applications,
including three-dimensional graphics, streaming audio and video, and
speech recognition applications.  To write programs for the Pentium,
you can choose from a wide range of high-level programming languages,
including the Java language.

\section{Networks, the Internet and the World Wide Web}
\noindent Most personal computers contain software that enables them to be
connected to various-sized {\it networks\index{networks}} of
computers.  Networks allow many individual users to share costly
computer resources, such as a high-speed printer or a large disk drive
or {\it application server} that is used to store and distribute both
data and programs to the computers on the network. Networks can range
in size from {\it local area networks (LANs)}, which connect computers
and peripherals over a relatively small area, such as within a lab or
a building, through {\it wide area networks (WANs)}, which can span
large geographic areas, such as cities and nations.


\marginnote{\vspace*{12pt}Client/server computing}
Application servers are just one example of {\it client/server
computing\index{client-server}}, a computing approach made possible by
networks.  According to this approach, certain computers on the
network are set up as {\it servers}, which provide certain
well-defined services to {\it client} computers.  For example, one
computer in a network may be set up as the {\it email server}, with
the responsibility of sending, receiving, and storing mail for all
users on the network.  To access their email on the email server,
individual users employ {\em client application software} that resides
on their desktop computers, such as Outlook Express or Eudora or Pine.
Similarly, another server may be set up as a {\it Web server}, with
the responsibility of storing and serving up Web pages for all the
users on the network.  Users can run Web browsers, another type of
client software, to access Web pages on the server.  Java is
particularly well suited for these types of {\em networked} or {\em
distributed} applications, where part of the application software
resides on a server and part resides on the client computer.


\splarge The {\it Internet\index{Internet}} (with a capital {\it I}) 
is a network of networks whose geographical area covers the entire
globe.  The {\it World Wide Web\index{World Wide Web}
(WWW\index{WWW})} is another example of distributed, client/server
computing.  The WWW is not a separate physical network.  Rather it is
a subset of the Internet that uses the {\it HyperText Transfer
Protocol (HTTP\index{HTTP})}. A {\it protocol}\index{protocol} is a
set of rules and conventions that govern how communication takes place
between two computers.  HTTP is a multimedia protocol, which means
that it supports the transmission of text, graphics, sound, and other
forms of information.  Certain computers within a network run special
software that enables them to play the role of HTTP (or Web) servers.
They store Web documents and are capable of handling requests for
documents from client browser applications.  The servers and clients
can be located anywhere on the Internet.\spnormallar

The documents stored on Web servers are encoded in a special
text-based language known as {\it HyperText Markup Language}, or {\it
HTML}\index{HTML}. Web browsers, such as Netscape's Navigator and
Microsoft's Internet Explorer, are designed to interpret documents
coded in this language.  The language itself is very simple.  Its basic
elements are known as {\it tags}, which consist of certain keywords or
other text contained within angle brackets, $<$ and $>$. For example,
if you wanted to italicize text on a Web page, you would
enclose it between the $<I>$ and $</I>$ tags.  Thus, the following HTML
code

\begin{jjjlisting}
\begin{lstlisting}
$<I>$Italic font$</I>$ can be used for $<I>$emphasis$</I>$.
\end{lstlisting}
\end{jjjlisting}

\noindent would be displayed by the Web browser as

\begin{extract}
{\it Italic font} can be used for {\it emphasis}.
\end{extract}

\noindent When you use a Web browser to surf the Internet, you repeatedly
instruct your browser to go to a certain location and retrieve
a page that is encoded in HTML.~For example, if you typed the
following {\it URL (Uniform Resource Locator)}\index{Uniform Resource
Locator}\index{URL}

\WWW
\begin{jjjlisting}
\begin{lstlisting}[commentstyle=\color{black}\small]
http://www.prenhall.com/morelli/index.html
\end{lstlisting}
\end{jjjlisting}

\noindent into your browser, the browser would send a message to the
Web server {\tt www} located in the {\tt prenhall.com} domain---the
{\tt prenhall} portion of this address specifies Prentice Hall and
the {\tt com} portion specifies the commercial domain of the
Internet---requesting that the document named \mbox{\tt index.html} 
in the {\tt morelli}
directory be retrieved and sent back to your computer
(Fig.~\ref{fig-http}). The beauty of the Web is that it is possible
to embed text, sound, video, and graphics within an HTML document,
making it possible to download a wide range of multimedia resources
through this (relatively) simple mechanism.

\begin{figure}[tb]
%\begin{graphic}
%\includegraphics{./art/0/0f2.eps}
%%\figaleft{CHPTR00:0f2.eps}
\figaleft{chptr00/0f2.eps}
{WWW: The client's browser requests a page from
a Web server.  When the HTML document is returned, it is
interpreted and displayed by the browser.
\label{fig-http}}
%\end{graphic}
\end{figure}

The Web has begun to change business, entertainment, commerce, and
education.  The fact that it is possible to download computer games
and other application software from the Web is changing the way software
and other digital products are purchased and distributed.  Similarly,
as noted earlier, many businesses have begun to organize their
information systems into {\em intranets}---private networks that implement
the HTTP protocol.  Currently, one of the biggest areas of development
on the Web is commerce.  As consumers become more comfortable
that credit-card information can be securely transmitted over the Web (as
it can over a telephone), the Web will explode as a marketing medium
as powerful, perhaps, as television is today.  Because Java has been
designed to support secure, distributed, networked applications, it is
ideally suited to be used as the language for these types of
applications.
%\epage

\section{Why Study Programming?}
\noindent A {\bf computer program} is a set of instructions that directs
the computer's behavior.  {\it Computer programming} is the art and
science of designing and writing programs.  Years ago it was widely
believed that entrance into the computer age would require practically
everyone to learn how to program.  But this did not prove to be true.
Today's computers come with so much easy-to-use software that knowing
how to use a computer no longer requires programming skills.


Another reason to study programming might be to enter into a career as
a computer scientist.  However, although programming is one of its
primary tools, computer science is a broad and varied discipline,
which ranges from engineering subjects, such as processor design, to
mathematical subjects, such as performance analysis.  There are many
computer scientists who do little or no programming as part of their
everyday work.  If you plan to major or minor in computer science, you
will certainly learn to program, but good careers in the computing
field are available to programmers and nonprogrammers alike.

One of the best reasons to study programming is because it is a
creative and enjoyable problem-solving activity.  This book will teach
you to develop well-designed solutions to a range of interesting
problems.  One of the best things about programming is that you can
actually see and experience your solutions as running programs.  As
many students have indicated, there's really nothing like the kick you
get from seeing your program solving a problem you've been struggling
with.  Designing and building well-written programs provides a
powerful sense of accomplishment and satisfaction.  What's more, Java
is a language that makes programming even more fun, because once
they're finished, many Java programs can be posted on the World Wide
Web (WWW) for all the world to see!



\section{Programming Languages}
\noindent Most computer programs today are written in a {\bf high-level
language\index{high-level language}}, such as Java, C, C++, or
FORTRAN. A programming language is considered high level if its
statements resemble English-language statements.  For example, all of
the languages just mentioned have some form of an ``if'' statement,
which says, ``if some condition holds, then take some action.''

Computer scientists have invented hundreds of high-level programming
languages, although relatively few of these have been put to practical
use.  Some of the widely used languages have special features that
make them suitable for one type of programming application or another.
COBOL (COmmon Business-Oriented Language), for example, is still
widely used in commercial applications.  FORTRAN (FORmula TRANslator)
is still preferred by some engineers and scientists.  C and C++ are
still the primary languages used by operating system programmers.

In addition to having features that make them suitable for certain
types of applications, high-level languages use symbols and notation
that make them easily readable by humans.  For example, arithmetic
operations in Java make use of familiar operators such as ``$+$'' and
``$-$'' and ``/'', so that arithmetic expressions look more or less the
way they do in algebra.  So, to take the average of two numbers, you
might use the expression

\begin{jjjlisting}
\begin{lstlisting}
(a + b) / 2
\end{lstlisting}
\end{jjjlisting}

\noindent The problem is that computers cannot directly understand such
expressions.  In order for a computer to run a program, the program
must first be translated into the computer's {\it machine
language\index{machine language}}, which is the language
understood by its CPU or microprocessor.  Each type of microprocessor
has its own particular machine language.  That's why when you buy
software it runs either on a Macintosh, which uses the Power-PC chip,
or on a Windows machine, which uses the Pentium chip, but not on both.
\marginnote{Platform independence}
When a program can run on just one type of chip, it is known as
{\it platform dependent\index{platform independence}}.

In general, machine languages are based on the {\it binary code}, a
two-valued system that is well suited for electronic devices.  In a
binary representation scheme, everything is represented as a sequence
of 1's and 0's, which corresponds closely to the computer's electronic
``on'' and ``off'' states.  For example, in binary code, the number 13
would be represented as 1101. Similarly, a particular address in the
computer's memory might be represented as 01100011, and an instruction
in the computer's instruction set might be represented as 001100.

The instructions that make up a computer's machine language are very
simple and basic.  For example, a typical machine language might
include instructions for ADD, SUBTRACT, DIVIDE, and MULTIPLY, but it
wouldn't contain an instruction for AVERAGE. In most cases, a single
instruction, called an {\em opcode}, carries out a single machine
operation on one or more pieces of data, called its {\em operands}.
Therefore, the process of averaging two numbers would have to be
broken down into two or more steps.  A machine language instruction
itself might have something similar to the following format, in which
an opcode is followed by several operands, which refer to the
locations in the computer's primary memory where the data are stored.
The following instruction says ADD the number in LOCATION1 to the
number in LOCATION2 and store the result in LOCATION3:

%%%RAM\begin{table}[h]
\begin{center}
\UNTB\begin{tabular}{llll}
\multicolumn{4}{l}{
\color{cyan}
\rule[0pt]{21.1pc}{1pt}}\\[2pt]
%%%RAM\UNTBCH{Opcode} &\UNTBCH{Operand 1} &\UNTBCH{Operand 2} &\UNTBCH{Operand 3}
{Opcode} &{Operand 1} &{Operand 2} &{Operand 3}
\\[-4pt]\multicolumn{4}{l}{
\color{cyan}
\rule[0pt]{21.1pc}{0.5pt}}\\[2pt]
{\tt 011110} & {\tt 110110}   & {\tt 111100}   & {\tt 111101}\\
(ADD)        & (LOCATION 1)   & (LOCATION 2)   & (LOCATION 3)
\\[-4pt]\multicolumn{4}{l}{
\color{cyan}
\rule[0pt]{21.1pc}{1pt}}\\[-12pt]
\end{tabular}
\end{center}
\endUNTB

%%RAM\end{table}

\noindent Given the primitive nature of machine language, an
expression like $(a + b)/2$ would have to be translated
into a sequence of several machine language instructions that, in
binary code, might look as follows:

\medskip
%%%RAM\centerline{\vbox{
%%%RAM\halign{\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&
%%%RAM\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&
%%%RAM\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&
%%%RAM\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil&\hfil#\hfil\cr
%%%RAM0&1&1&1&1&0&1&1&0&1&1&0&1&1&1&1&0&0&1&1&1&1&0&1\cr
%%%RAM0&0&0&1&0&1&0&0&0&1&0&0&0&1&0&0&0&1&0&0&1&1&0&1\cr
%%%RAM0&0&1&0&0&0&0&1&0&0&0&1&0&1&0&1&0&1&1&1&1&0&1&1\cr
%%%RAM}}}
\begin{jjjlisting}
\begin{lstlisting}
              011110110110111100111101
              000101000100010001001101
              001000010001010101111011
\end{lstlisting}
\end{jjjlisting}
\medskip

In the early days of computing, before high-level languages were
developed, computers had to be programmed directly in their machine
languages, an extremely tedious and error-prone process.  Imagine how
\mbox{difficult} it would be to detect an error that consisted of putting a 0
in the preceding program where a 1 should occur!

Fortunately, we no longer have to worry about machine languages,
because special programs can be used to translate a high-level or {\bf
source code\index{source code}} program into machine language code or
{\bf object code\index{object code}}, which is the only code that can
be {\em executed} or run by the computer.  In general, a program that translates
source code to object code is known as a {\it
translator\index{translator}} (Fig.~\ref{fig-translator}).  Thus, with
suitable translation software for Java or C++ we can write programs as
if the computer could understand Java or C++ directly.

\begin{figure}[tb]
%\begin{graphic}
%\includegraphics{./art/0/0f3.eps}
%%%\figaleft{CHPTR00:0f3.eps}
\figaright{chptr00/0f3.eps}
{Translator software translates high-level
{\it source code} to machine language {\it object code}.
\label{fig-translator}
\label{pg-fig-translator}}
%\end{graphic}
\end{figure}

Source code translators come in two varieties.  An {\bf
interpreter\index{interpreter}} translates a single line of source
code directly into machine language and executes the code before going
on to the next line of source code.  A {\bf compiler\index{compiler}}
translates the entire source code program into {\em executable} object
code, which means that the object code can then be run directly
without further translation.

There are advantages and disadvantages to both approaches.
Interpreted programs generally run less efficiently than compiled
programs, because they must translate and execute each line of the
program before proceeding to the next line. If a line of code is
repeated, an interpreter would have to translate the line each time it
is encountered. By contrast, once compiled, an object program is just
executed without any need for further translation.  It is also much
easier to refine compiled code to make it run more efficiently.  But
interpreters are generally quicker and easier to develop and provide
somewhat better error messages when things go wrong.  Some languages
that you may have heard of, such as BASIC, LISP, and Perl, are mostly
used in interpreted form, although compilers are also available for
these languages.  Programs written in COBOL, FORTRAN, C, C++, and
Pascal are compiled.  As we will see in the next section, Java
programs use both compilation and interpretation in their translation
process.

\vspace*{-10pt}
\section{Why Java?}
\noindent Originally named ``Oak'' after a tree outside the office of its
developer, James Goslin, Java is a relatively young programming
language.  It was initially designed by Sun Microsystems in 1991 as a
language for embedding programs into electronic consumer devices, such
as microwave ovens and home security systems.  However, the tremendous
popularity of the Internet and the World Wide Web (WWW)
led Sun to recast Java as a language for embedding programs into
Web-based applications.  As you recall, the Internet is a
global computer network, and the WWW is that portion of the network
that provides multimedia access to a vast range of information.  Java
has become one of the most important languages for Web and Internet
applications.

Java has also generated significant interest in the business
community, where it is has proved to have tremendous commercial
potential.  In addition to being a useful tool for helping businesses
to promote their products and services over the Internet, Java is also a
good language for distributing software and providing services to
employees and clients on private corporate networks or intranets.

Because of its original intended role as a language for programming
microprocessors embedded in consumer appliances, Java has been
designed with a number of interesting features:


\begin{BL}
%%%\begin{itemize}

\item  Java is {\it\bf object oriented}.
Object-oriented languages divide programs into separate modules,
called objects, that encapsulate the program's data and
operations. Thus, {\em object-oriented programming (OOP)} and {\em
object-oriented design (OOD)} refer to a particular way of organizing
\marginnote{Object-oriented Languages}
programs, one which is rapidly emerging as the preferred approach for
building complex software systems. Unlike the C++ language, in which
object-oriented features were grafted onto the C language, Java was
designed from scratch as an object-oriented language.

\item  Java is {\it robust}, meaning that errors in Java programs
don't cause system crashes as often as errors in other programming
languages.  Certain features of the language enable many potential
errors to be detected before a program is run.

\item  Java is {\it platform independent}.
\marginnote{Platform independence} 
A {\em platform}, in this context, is just a particular kind of
computer system, such as a Macintosh or Windows system. Java's
trademark is ``Write once, run anywhere.'' This means that a Java
program can be run without changes on different kinds of
computers.  This is not true for other high-level programming
languages. This {\em portability} -- the ability to run on virtually
any platform -- is one reason that Java is well suited for WWW
applications.

\item Java is a {\it distributed} language, which means that its
programs can be designed to run on computer networks.  In addition to
the language itself, Java comes with an extensive collection of {\em
code libraries}---software that has been designed to be used directly
for particular types of applications---that make it particularly easy
to build software systems for the Internet and the WWW. This is one of
the reasons why Java is so well suited for supporting applications on
corporate networks.

\item  Java is a {\it secure} language.  Designed to be used
on networks, Java contains features that protect against {\it
untrusted code}---code that might introduce a virus or corrupt your
system in some way.  For example, once they are downloaded into your
browser, Web-based Java programs are prevented from reading and
writing information from and to your desktop computer.

%%%\end{itemize}
\end{BL}

\noindent Despite this list of attractive features, perhaps the best reason for
choosing Java as an introductory programming language is its potential
for bringing fun and excitement into learning how to program.  There
are few other languages in which a beginning programmer can write a
computer game or a graphically based application that can be
distributed on a Web page to just about any computer in the world.
The simplicity of Java's design and its easily accessible libraries
bring such accomplishments within reach of the most novice
programmers.

For example, we will work on projects throughout the text that involve
games and puzzles.  We start out in Chapter~2 by designing very simple
games that involve storing and retrieving data.  As we learn more
sophisticated programming techniques, we gradually build more
complexity into the games and puzzles.  For example, we learn how to
create interactive, two-person games in Chapter~4.  In Chapter~8, we
develop some games and puzzles that are played on virtual game boards.
Finally, in Chapter~14 we learn how to introduce games with multiple
players on different computers. To get a look at where we are headed
you might want to visit the authors' companion Web site:

\WWWleft
\begin{jjjlisting}
\begin{lstlisting}[commentstyle=\color{black}\small]
http://www.cs.trincoll.edu/~ram/jjj/
\end{lstlisting}
\end{jjjlisting}

\section{What Is \mbox{Object-Oriented} Programming?}

\noindent Java is an object-oriented (OO) language, and this book
takes an object-oriented approach to programming.  So before beginning
our discussion of Java, it is important that we introduce some of the
underlying concepts involved in object-oriented programming.  We need
to talk about what an object is, how objects are grouped into classes,
how classes are related to each other, and how objects use messages to
interact with and communicate with each other.

\subsection{Basic \mbox{Object-Oriented} Programming Metaphor: 
\\Interacting Objects}

A Java program, and any object-oriented program, is a collection of
interacting objects that models a collection of real-world
\marginfig{chptr00/kitchen.eps} {A model of a kitchen.}{fig-kitchen}

objects. Think of the model that a kitchen designer might use to
layout your new kitchen (Fig.~\ref{fig-kitchen}).  It will contain
objects that represent the various kitchen appliances and
cabinets. Each object in the model is a simplified version of the
corresponding real object.  For example, a rectangle might be used to
represent the refrigerator.

A kitchen model is mostly {\em static}. It doesn't change. Once put
into place, its various objects just stand there in a certain relation
to each other. By contrast, a computer program is {\em dynamic}. It
changes. It does things and performs certain actions.  The objects in
a computer program communicate with each other and they change over
time. In this respect, the objects that make up our computer programs
are very {\em anthropomorphic}, a big word that means ``like people.''
If we are eating together and I want you to pass me the salt, I say,
``Please pass me the salt,'' and you invariably comply.  Similarly,
when you (Student X) put your ATM card into an ATM machine, the ATM
object asks the bank's database object ``Give me Student X's bank
account object'' and the database invariably complies.  If you tell
the ATM you want to withdraw \$100 dollars it tells your bank account
object to deduct \$100 from your current balance. And so it goes.
Both you and your bank account are changed objects as a result of
the transaction.

\subsection{What is an Object?}

So what is an object? Just as in the real world, an {\bf object} is
any thing whatsoever. An object can be a physical thing, such as a
{\tt Car}, or a mental thing, such as an {\tt Idea}.  It can be a
natural thing, such as an {\tt Animal}, or an artificial, human-made
thing, such as a {\tt ATM}. A program that manages an ATM would
involve {\tt BankAccount}s and {\tt Customer} objects. A chess program
would involve a {\tt Board} object and {\tt ChessPiece} objects.

Throughout this text, we will use the notation shown in
Figure~\ref{fig-umlobj1} to depict objects and to illustrate
object-oriented concepts. The notation is known as the {\bf Unified
Modeling Language}, or {\bf UML} for short, and it is a standard in
the object-oriented programming community.  As the diagram shows, an
object is represented by a rectangle whose label consists of the
object's (optional) id and its type. An object's {\em id} is the name
by which it is referred to in the computer program. In this case we
show a {\tt ATM} object, who's id is not given, and a {\tt ChessPiece}
object, named {\tt pawn1}. An object's label is always underlined.

\begin{figure}[tb]
\figaleft{chptr00/umlobj1.eps} {In UML, objects are represented by
rectangles that are labeled with a two-part label of the form {\it
id:Type}. The object's label is always underlined.
\label{fig-umlobj1}
\label{pg-fig-umlobj1}}
\end{figure}

\subsection{Attributes and Values}

Just as with real objects, the objects in our programs have certain
characteristic {\bf attributes}. For example, an {\tt ATM} object
would have a current amount of {\tt cash} that it could dispense. A
{\tt ChessPiece} object might have a pair of {\tt row} and {\tt
column} attributes that specify its position on the chess
board. Notice that an object's attributes are themselves objects. The
ATM's {\tt cash} attribute and the chess piece's {\tt row} and {\tt
column} attributes are {\tt Number}s.

Figure~\ref{fig-umlobj2} shows two {\tt ATM} objects and their
respective attributes. As you can see, an object's attributes are
listed in a second partition of the UML diagram. Notice that each
attribute has a value. So the {\tt lobby:ATM} has a \$8650.0 in {\tt
cash}, while the {\tt drivethru:ATM} has only \$150.0 in {\tt cash}.

\begin{figure}[h]
\figaleft{chptr00/umlobj2.eps} 
{A second partition of an object diagram is used to display
the object's attributes and their values. 
\label{fig-umlobj2}
\label{pg-fig-umlobj2}}
\end{figure}

We sometimes refer to the collection of an object's attributes and
values as its {\it state}. For example, the current state of the
{\tt lobby:ATM} is \$8650.0 in cash.  Of course, this is a gross
simplification of an ATM's state, which would also include many other
attributes. But, hopefully, you see the point.

\subsection{Actions and Messages}

In addition to their attributes, objects also have characteristic {\bf
actions} or behaviors. As we have already said, objects in programs
are dynamic. They do things or have things done to them. In fact,
programming in Java is largely a matter of getting objects to perform
certain actions for us.  For example, in a chess program the {\tt
ChessPiece}s have the ability to {\tt moveTo()} a new position on the
chess board.  Similarly, when a customer pushes the ``Current
Balance'' button on an ATM machine, this is telling the ATM to {\tt
report()} the customer's current bank balance. (Note how we use
parentheses to distinguish actions from objects and attributes.)

\begin{figure}[tb]
\figaright{chptr00/umlmsg1.eps} {Messages in UML are represented by labeled
arrows. In this example, we are telling a pawn to move from its
current position to row 3 column 4.  
\label{fig-umlmsg1}
\label{pg-fig-umlmsg1}}
\end{figure}

The actions that are associated with an object can be used to send
messages to the objects and to retrieve information from objects.  A
{\bf message} is the passing of information or data from one object to
another.  Figure~\ref{fig-umlmsg1} illustrates how this works. In UML,
messages are represented by arrows. In this example, we are telling
{\tt pawn1:ChessPiece} to {\tt moveTo(3,4)}. The numbers 3 and 4 in
this case are arguments that tell the pawn what square to move to. (A
chess board has 8 rows and 8 columns and each square is identified by
its row and column coordinates.) In general, an {\bf argument} is a
data value that specializes the content of a message in some way. In
this example we are telling the pawn to move forward by 1 row. If we
wanted the pawn to move forward by 2 rows, we would send the message
{\tt moveTo(4,4)}.

The diagram in Figure~\ref{fig-umlmsg2} depicts a sequence of
messages representing an idealized ATM transaction. First, an ATM
customer asks the ATM machine to report his current balance. The ATM
machine in turn asks the customer's bank account to report the
customer's balance. The ATM receives the value \$528.52 from the bank
account and passes it along to the customer.  In this case, the
message does not involve an argument. But it does involve a result. A
{\bf result} is information or data that is returned to the object
that sent the message.

\begin{figure}[h]
\figascaled{chptr00/atmreport.png}{0.5} {This UML diagram illustrates an ATM
transaction in which a customer asks the ATM machine for his current
balance. The ATM gets this information from an object representing the
customer's bank account and passes it to the customer.}
{fig-umlmsg2}
\end{figure}

Obviously, in order to respond to a message, an object has to know how
to perform the action that is requested. The pawn has to know how to
move to a designated square. The ATM has to know how to find out the
customer's current balance. Indeed, an object can only respond to
messages that are associated with its characteristic actions and
behaviors.  You can't tell an ATM to move forward 2 squares. And you
can't ask a chess piece to tell you your current bank balance.

Responding to a message or performing an action sometimes causes a
change in an object's state. For example, after performing {\tt
moveTo(3, 4)}, the pawn will be on a different square. Its position
will have changed. On the other hand, some messages (or actions) leave
the object's state unchanged. Reporting the customer's bank account
balance doesn't change the balance.

\subsection{What is a Class?}

A {\bf class} is a template for an object. A class encapsulates the
attributes and actions that characterize a certain type of object. In
an object-oriented program, classes serve as blueprints or templates
for the objects that the program uses. We say that an object is an
{\bf instance} of a class.  A good analogy here is to think of a class
as a cookie cutter and its objects, or instances, as individual
cookies.  Just as we use the cookie cutter to stamp out cookies of a
certain type, in an object-oriented program, we use a definition of a
class to create objects of a certain type.

Writing an object-oriented program is largely a matter of designing
classes and writing definitions for those classes in Java.  Designing
a class is a matter of specifying all of the attributes and behaviors
that are characteristic of that type of object.

For example, suppose we are writing a drawing program. One type of
object we would need for our program is a rectangle. A {\tt Rectangle}
object has two fundamental attributes, a {\tt length} and a {\tt
width}.  Given these attributes, we can define characteristic
rectangle actions, such as the ability to calculate its area and the
ability to draw itself. Identifying an object's attributes and actions
is the kind of design activity that goes into developing an object-oriented
program.

\begin{figure}[tb]
\figaleft{chptr00/rectclass.eps} 
{A UML diagram of the {\tt Rectangle} class.
\label{fig-umlrect}
\label{pg-fig-umlrect}}
\end{figure}

Figure~\ref{fig-umlrect} shows a UML diagram of our {\tt Rectangle}
class. Like the symbol for an object, a UML class symbol has up to
three partitions. Unlike the UML object symbol, the label for a
UML class gives just the class's name and it is not underlined. The
second partition lists the class's attributes and the third partition
lists the classes actions. Our rectangle has four attributes. The
first two, {\tt x} and {\tt y}, determine a rectangles position on a
two-dimensional graph. The second two, {\tt length} and {\tt width},
determine a rectangle's dimensions.  Note that the attributes have no
values. This is because the class represents a general {\em type} of
rectangle. It specifies what all rectangles have in common, without
representing any particular rectangle.  Like a cookie cutter for a
cookie, a class gives the general shape of an object. The content is
not included.

\subsection{Variables and Methods}

Up to this point we have been using the terms {\em attribute} and {\em
action} to describe an object's features. We will continue to use this
terminology when talking in general about objects or when talking
about an object or class represented by a UML diagram.

However, when talking about a programming language, the more common
way to describe an object's features are to talk about its variables
and methods. A {\bf variable}, which corresponds to an attribute, is a
named memory location that can store a certain type of value.  You can
think of a variable as a special container that can only hold objects
of a certain type.  For example, as Figure~\ref{fig-umlrect} shows,
{\tt Rectangle}'s {\tt length} and {\tt width} are variables that can
store a certain type of numeric value known as an {\tt int}. An {\tt
int} value is a whole number, such as 76 or -5.

A {\bf method}, which corresponds to an action or a behavior, is a
named chunk of code that can be called upon or {\em invoked} to
perform a certain pre-defined set of actions. For example, in our {\tt
Rectangle} object, the {\tt calculateArea()} method can be called upon
to calculate the rectangle's area.  It would do this, of course, by
multiplying the rectangle's length by its width. Similarly, the {\tt
draw()} method can be invoked to draw a picture of the rectangle. It
would take the actions necessary to draw a rectangle on the console.

\subsection{Instance versus Class Variables and Methods}

Variables and methods can be associated either with objects or their
classes. An {\bf instance variable} (or {\bf instance method}) is a
variable (or method) that belongs to an object. By contrast, a {\bf
class variable} (or {\bf class method}) is a variable (or method) that
is associated with the class itself.  An example will help make this
distinction clear.

An instance variable will have different values for different
instances.  For example, individual {\tt Rectangle}s will have
different values for their {\tt length}, {\tt width}, {\tt x}, and
{\tt y} variables.  So these are examples of instance variables.  The
{\tt calculateArea()} method is an example of an instance method
because it uses the instance's current length and width values in its
calculation. Similarly, the {\tt draw()} method is an instance method,
because it uses the object's length and width to draw the object's
shape.

An example of a class variable would be a variable in the {\tt
Rectangle} class that is used to keep track of how many individual
{\tt Rectangle}s have been created. (Our drawing program might need
this information to help manage its memory resources.)  Suppose we
name this variable {\tt nRectangles} and suppose we add 1 to it each
time a new {\tt Rectangle} instance is created.

An example of a method that is associated with the class is a special
method known as a {\bf constructor}. This is a method used to create
an object. It is used to create an instance of a class. Calling a
constructor to create an object is like pressing the cookie cutter
into the cookie dough: the result is an individual cookie (object).

\begin{figure}[tb]
\figaleft{chptr00/rects.eps} {The {\tt Rectangle} class and two of its
instances. Note that the class variable, {\tt nRectangles}, is
underlined to distinguish it from {\tt length} and {\tt width}, the
instance variables.
\label{fig-rects}
\label{pg-fig-rects}}
\end{figure}

Figure~\ref{fig-rects} illustrates these concepts. Note that class
variables are underlined in the UML diagram.  We have modified the
{\tt Rectangle} class to include its constructor method, which is
named {\tt Rectangle()}. Note that it takes four arguments,
representing the values that we want to give as the rectangle's {\it
x}, {\it y}, length and width respectively.  Note also how the {\tt
Rectangle} class's {\tt nRectangles} variable has a value of 2,
representing that two {\tt Rectangle} instances have been created.
These are shown as members of the {\tt Rectangle} class.

It won't be obvious to you at this point, but {\tt nRectangles} is a
value that has to be associated with the {\tt Rectangle} class, not
with its instances.  To see this let's imagine what happens when a new
{\tt Rectangle} instance is created. Figure~\ref{fig-rectconstr}
illustrates the process.  When the {\tt Rectangle()} constructor is
invoked, its arguments (100, 50, 25, 10) are used by the {\tt
Rectangle} class to create a {\tt Rectangle} object located at {\it
x=100}, {\it y=50} and with a length of 25 and width of 10. The
constructor method also increases the value of {\tt nRectangles} by 1
as a way of keeping count of how many objects it has created.

\begin{figure}[h]
\figaleftscaled{chptr00/rectconstr.eps}{0.8} 
{Constructing a {\tt Rectangle} instance.
\label{fig-rectconstr}
\label{pg-fig-rectconstr}}
\end{figure}

\subsection{Class Hierarchy and Inheritance}

How are classes related to each other?  In Java, and in any other
object-oriented language, classes are organized in a class hierarchy.
A {\bf class hierarchy} is like an upside-down tree. At the very top
of the hierarchy is the most general class. In Java, the most general
class is the {\tt Object} class.  The classes below {\tt Object} in
the hierarchy are known as its {\bf subclasses}.  Since all of the
objects we use in our programs belong to some class or other, this is
like saying that all objects are {\tt Object}s.

Figure~\ref{fig-classhier} illustrates the concept of a class hierarchy
using the classes that we have described in this section.  Notice that
the {\tt Object} class occurs at the top of the hierarchy.  It is the
most general class. It has features that are common to all Java
objects. As you move down the hierarchy, the classes become more and
more specialized. A {\tt Rectangle} is an {\tt Object} but it contains
attributes -- length and width -- that are common to all rectangles
but not to other objects in the hierarchy. For example, an {\tt ATM}
object does not necessarily have a length and a width. Notice that
we have added a {\tt Square} class to the hierarchy. A {\tt Square}
is a special type of {\tt Rectangle}, namely one who's length equals
its width.

\begin{figure}[tb]
\figa{chptr00/classhier.eps} 
{A hierarchy of Java classes.}
{fig-classhier}

\end{figure}

To introduce some important terminology associated with this kind of
\marginnote{Superclass and subclass} hierarchy, we say that the {\tt
Rectangle} class is a subclass of the {\tt Object} class. The {\tt
Square} class is a subclass of both {\tt Rectangle} and {\tt Object}.
Classes that occur above a given class in the hierarchy are said to be
its {\bf superclasses}. Thus {\tt Rectangle} class is superclass of
the {\tt Square} class. The {\tt Object} class is also a superclass of
{\tt Square}.  In general, we say that a subclass {\em extends} a
superclass, meaning that it adds additional elements (attributes
and/or methods) to those contained in its superclasses. We saw this in
the case of the {\tt Square} class. It adds the feature that its
length and width are always equal.

Another important concept associated with a class hierarchy is the
\marginnote{Class inheritance}
notion of {\bf class inheritance}, whereby a subclass inherits
elements (attributes and/or methods) from its superclasses.  To take
an example from the natural world, think of the sort of inheritance
that occurs between a horse and a mammal. A horse is a mammal. So
horses inherit the characteristic of being warm blooded by virtue of
also being mammals. (This is different from the kind of individual
inheritance whereby you inherit your mother's blue eyes and your
father's black hair.)

To illustrate how inheritance works, lets go back to our chess
program. There are several different types of {\tt ChessPiece}s.
There are {\tt Pawn}s, and {\tt Knight}s, and {\tt Queen}s and {\tt
King}s.  Figure~\ref{fig-chesshier} illustrates the chess piece
hierarchy.  A pair of attributes that all chess pieces have in common
is their {\tt row} and {\tt column} position on the chess
board. Because all chess pieces have these attributes in common, they
are located at the top of the {\tt ChessPiece} hierarchy and inherited
by all {\tt ChessPiece} subclasses. Of course, the {\tt row} and {\tt
column} attributes are given different values in each {\tt ChessPiece}
object.

\begin{figure}[tb]
\figaleft{chptr00/chesshier-small.png} 
{The {\tt ChessPiece} hierarchy.
\label{fig-chesshier}
\label{pg-fig-chesshier}}
\end{figure}

One of the actions that all chess pieces have in common is that they
can {\tt moveTo()} a given square on the chess board. But different
types of chess pieces have different ways of moving. For example, a
{\tt Bishop} can only move along diagonals on the chess board, whereas
a {\tt Rook} can only move along a row or column on the chess board.
So, clearly, we can't describe a {\tt moveTo()} method that will work
for all {\tt ChessPiece}s.  This is why we put the {\tt moveTo()}
method in all of the {\tt ChessPiece} subclasses. The {\tt ChessPiece}
class also has a {\tt moveTo()} method, but note that its name is
italicized. This indicates that it cannot be completely defined at
that level.

Finally, note that in chess, the king has certain special attributes
and actions. Thus only the king can be put {\em in check}. This means
that the king is under attack and in danger of being captured, thereby
ending the game. Similarly, only the king has the ability to castle.
This is special move that a king can make together with one of its
rooks under certain conditions.  Thus, the reason we show the {\tt
inCheck} attribute and {\tt castle()} action in the {\tt King} class
is because these are characteristics that particular to {\tt King}s.

In this way, a class hierarchy represents a {\em specialization} of
classes as you move from top to bottom. The most general class, {\tt
ChessPiece}, is at the top of the hierarchy.  Its attributes and
methods are passed on to (inherited by) its subclasses. However, in
addition to the attributes and methods they inherit from their
superclasses, the subclasses define their own special attributes and
methods. Each of the subclasses, {\tt Pawn}, {\tt Bishop}, and so on,
represents some kind of specialization of the superclass. In this
example, each of the subclasses have their own distinctive ways of
moving. And the {\tt King} subclass has unique attributes and actions
({\tt inCheck} and {\tt castle()}.


\subsection{Principles of \mbox{Object-Oriented} Design}

\noindent As we have discussed, an object-oriented program is composed
of many objects communicating with each other. The process of
designing an object-oriented program to solve some problem or other
involves several important principles:

\begin{BL}
\item {\bf Divide-and-Conquer Principle.}  Generally, the first step
in designing a program is to divide the overall problem into a number
of objects that will interact with each other to solve the
problem. Thus, an object-oriented program employs a {\em division of
labor} much as we do in organizing many of our real-world tasks. This
{\em divide-and-conquer} approach is an important problem-solving
strategy.

\item {\bf Encapsulation Principle.} Once the objects are identified,
the next step involves deciding, for each object, what attributes it
has and what actions it will take.  The goal here is to encapsulate
within each object the expertise needed to carry out its role in the
program.  Each object is a self-contained module with a clear
responsibility and the tools (attributes and actions) necessary to
carry out its role. Just as a dentist encapsulates the expertise
needed to diagnose and treat a tooth ache, a well-designed object
contains the information and methods needed to perform its role.

\item {\bf Interface Principle.} In order for objects to work
cooperatively and efficiently, we have to clarify exactly how they
should interact, or {\em interface}, with one another.  An object's
interface should be designed to limit the way the object can be used
by other objects. Think of how the different interfaces presented by a
digital and analog watch determine how the watches are used.  In a
digital watch, time is displayed in discrete units, and buttons are
used to set the time in hours, minutes and seconds. In an analog
watch, the time is displayed by hands on a clock face, and time is
set, less precisely, by turning a small wheel.

\item {\bf Information Hiding Principle.} In order to enable objects
to work together cooperatively, certain details of their individual
design and performance should be hidden from other objects. To use the
watch analogy again, in order to use a watch we needn't know how its
time keeping mechanism works. That level of detail is hidden from us.
Hiding such implementation details protects the watch's mechanism, while
not limiting its usefulness. 

\item {\bf Generality Principle.}  To make objects as generally useful
as possible, we design them not for a particular task but rather for a
particular {\em kind} of task.  This principle underlies the use of
software libraries.  As we will see, Java comes with an extensive
library of classes that specialize in performing certain kinds of
input and output operations. For example, rather than having to write
our own method to print a message on the console, we can use a library
object to handle our printing tasks.

\item {\bf Extensibility Principle.} One of the strengths of the
object-oriented approach is the ability to extend an object's behavior
to handle new tasks. This also has its analogue in the everyday
world. If a company needs sales agents to specialize in hardware
orders, it would be more economical to extend the skills of its
current sales agents instead of training a novice from scratch.  In
the same way, in the object-oriented approach, an object whose role is
to input data might be specialized to input numeric data.

\item {\bf Abstraction Principle.} Abstraction is the ability to focus
on the important features of an object when trying to work with
large amounts of information.  For example, if we are trying to
design a floor plan for a kitchen, we can focus on the shapes
and relative sizes of the appliances and ignore attributes such
as color, style, and manufacturer.  The objects we design in
our Java programs will be abstractions in this sense because they
ignore many of the attributes that characterize the real objects
and focus only on those attributes that are essential for solving
a particular problem.

%%%together into a single {\em chunk}, a
%%%term coined by George Miller in his 1956 article ``The Magic Number
%%%Seven, Plus or Minus Two.'' Miller claimed that humans have the
%%%ability to manage only seven (plus or minus two) chunks of information
%%at one time. 
%%%Therefore, we manage large quantities of information by
%%%forming abstractions. For example, it is easier to remember a long
%%%string of digits if we chunk the digits. So a phone number gets
%%%organized into three chunks (200-990-1179), rather than one chunk
%%%consisting of 10 digits (2009901179).  In the same way, an is an
%%%abstraction because it organizes data and actions into a single module
%%%that can be dealt with as a whole.

\end{BL}

\noindent These, then, are the principles that will guide our
discussion as we learn how to design and write object-oriented Java
programs.

\secSMHleft{Chapter Summary}%
\secKTH{Technical Terms}%
\begin{KT}
action (behavior)

argument

attribute

class

class inheritance

class hierarchy 

class method

class variable

compiler

computer program

constructor

high\mbox{-}level language

instance

instance method

instance variable

interpreter

method

message

object

object code

object oriented

result

source code

subclass

superclass

Unified Modeling Language (UML)

variable
\end{KT}

%%\vfill\newpage%


\secSMHtwo{Summary of Important Points}
\begin{SMBL}
\item A computer system generally consists of input/output devices,
primary and secondary memory, and a central processing unit.  A
computer can only run programs in its own {\it machine language},
which is based on the {\it binary code}. Special programs known as
{\it compilers} and {\it interpreters} translate {\it source code}
programs written in a {\it high-level language}, such as Java, into
machine language {\it object code} programs.

\item {\it Application software} refers to programs designed to
provide a particular task or service; {\it systems software} assists
the user in using application software.

\item The {\it client/server} model is a form of {\it distributed
computing} in which part of the software for a task is stored on a
{\it server} and part on {\it client} computers.

\item  HyperText Markup Language (HTML) is the language used to
encode WWW documents.

\item A Java program is a set of interacting objects.  This is the
basic metaphor of {\it object-oriented programming}.

\item An {\em object} in a Java program encapsulates the program's
{\em attributes} (or {\em variables}) and {\em actions} (or {\em
methods}).  A variable is a named memory location where data of
appropriate type can be stored. A method is a named section of code
that can be called (or invoked) when needed.  

\item An object's methods are used to pass messages to it. 

\item A {\em class} is an abstract template that defines the
characteristics and behaviors of all objects of a certain type.

\item An object is an {\em instance} of a class. An object has {\em
instance methods} and {\em instance variables}. A {\em class method}
(or {\em class variable}) is a method (or variable) that is associated
with the class itself, not with its instances.

\item A {\em constructor} is a special method that is used to
construct objects.

\item Java classes are organized into a {\em class hierarchy}, with the
{\tt Object} class at the top of the hierarchy. For a given class, classes
that occur below it in the hierarchy are called its {\em subclasses},
while classes that occur above it are called its {\em superclasses}.

\item Classes {\em inherit} attributes and methods from their superclasses.
This is known as {\em class inheritance}.

\item The main principles of the object-oriented programming approach
are as follows:

\begin{SMBSE}
\item Divide and Conquer: Successful problem solving involves breaking
a complex problem into objects.

\item Encapsulation and Modularity: Each object should be assigned a
clear role.

\item Public Interface: Each object should present a clear public
interface that determines how other objects will use it.

\item Information Hiding: Each object should shield its users from
unnecessary details of how it performs its role.

\item Generality: Objects should be designed to be as general as
possible.

\item Extensibility: Objects should be designed so that their
functionality can be extended to carry out more specialized tasks.

\item {\it Abstraction} is the ability to group a large quantity of
information into a single chunk so it can be managed as a single
entity.  

\end{SMBSE}
\end{SMBL}

\secEXRHtwo{Exercises}
%%\section{Exercises}
\begin{EXRtwo}
\item  Fill in the blanks in each of the following statements.

\begin{EXRtwoLL}
\baselineskip=14pt\item Dividing a problem or a task into parts is an
example of the \rule{60pt}{0.5pt} principle.

\item  Designing a class so that it shields certain parts of an object from
other objects is an example of the \rule{60pt}{0.5pt} principle.

\item  Java programs that can run without change on a wide variety
of computers is an example of \rule{60pt}{0.5pt}~.

\item  The fact that social security numbers are divided into
three parts is an example of the \rule{60pt}{0.5pt} principle.

\item  To say that a program is robust means that \rule{60pt}{0.5pt} .

\item An \rule{60pt}{0.5pt} is a separate module that encapsulates a
Java program's attributes and actions.
\end{EXRtwoLL}
\baselineskip=11pt

%%\newpage
\item  Explain the difference between each of the following pairs
of concepts.

\begin{EXRtwoLL}
\item  {\it hardware} and {\it software}
\item  {\it systems} and {\it application} software
\item  {\it compiler} and  {\it interpreter}
\item  {\it machine language} and {\it high-level language}
\item  {\it general-purpose} and {\it special-purpose} computer
\item  {\it primary} and {\it secondary} memory
\item  the {\it CPU} and the {\it ALU}
\item  the {\it Internet} and the {\it WWW}
\item  a {\it client} and a {\it server}
\item  {\it HTTP} and {\it HTML}
\item  {\it source} and {\it object} code
\end{EXRtwoLL}


\item Fill in the blanks in each of the following statements.
\begin{EXRtwoLL}
\baselineskip=13pt\item A \rule{50pt}{0.5pt} is a set of instructions
that directs a computer's behavior.
\item  A disk drive would be an example of a \rule{60pt}{0.5pt}  device.
\item  A mouse is an example of an  \rule{60pt}{0.5pt}  device.
\item  A monitor is an example of an  \rule{60pt}{0.5pt}  device.
\item  The computer's \rule{60pt}{0.5pt} functions like a scratch pad.
\item  Java is an example of a \rule{60pt}{0.5pt}  programming language.
\item  The Internet is a network of \rule{60pt}{0.5pt} .
\item  The protocol used by the World Wide Web is the \rule{60pt}{0.5pt} 
protocol.
\item  Web documents are written in \rule{60pt}{0.5pt} code.
\item  A \rule{60pt}{0.5pt}  is a networked computer that is used to store data
for other computers on the network.
\end{EXRtwoLL}

\baselineskip=11pt\item  Identify the component of computer hardware that is
responsible for the following functions.
\begin{EXRtwoLL}
\item  executing the {\it fetch-execute cycle}
\item  arithmetic operations
\item  executing instructions
\item  storing programs while they are executing
\item  storing programs and data when the computer is off
\end{EXRtwoLL}

\item  Explain why a typical piece of software, such as a
word processor, cannot run on both a Macintosh and a Windows
machine.

\item  What advantages do you see in platform independence?
What are the disadvantages?

\item  In what sense is a person's name an abstraction?
In what sense is any word of the English language an abstraction?

\item  Analyze the process of writing a research paper
in terms of the divide-and-conquer and encapsulation principles.

\item  Analyze your car by using object-oriented design
principles. In other words, pick one of your car's systems, such as
the braking system, and analyze it in terms of the divide-and-conquer,
encapsulation, information-hiding, and interface principles.

\item Make an object oriented analysis of the interaction between,
a student, librarian, and a library database when a student checks
a book out of a college library.

\end{EXRtwo}

%%% BF Terms in this Chapter

%% computer program
%% high-level language
%% source code
%% object code
%% interpreter
%% compiler
%% object oriented
%% object
%% Unified Modeling Language (UML)
%% attribute
%% actions (behaviors)
%% message
%% argument
%% result
%% class
%% instance
%% variable
%% method
%% instance variable
%% instance method
%% class method
%% class  variable
%% constructor
%% class hierarchy
%% subclass
%% superclass
%% class inheritance

